---
title: "Appendix"
subtitle: "GEOG246-346"
date: "`r Sys.Date()`"
output:
  prettydoc::html_pretty:
    theme: architect
    highlight: github
    fig_caption: yes
    number_sections: yes
    toc_depth: 4
    toc: yes
    css: unit.css
vignette: >
  %\VignetteIndexEntry{Unit 2 Module Appendix}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


# Answers to practice
## Module 1
### Practice 1
#### Questions
1. Answers [here](https://r-spatial.github.io/sf/articles/sf1.html#simple-feature-geometry-types).

2. Assuming the `tibble` has x and y or lat/long coordinates, you apply the function `st_as_sf` with the "coords" argument set to specify which columns contain the x and y coordinates. 

3. `sf::plot` by default plots one panel per variable. You can create a single panel by specifying the variable you want, or by using the `st_geometry` argument to strip out the geometry from object. It also prevent distortions that sometimes occur when overlaying subsequent features on top of a base map. 

4. For a single point you provide an x and y coordinate, otherwise you give an input matrix containing x and y coordinates. A polygon requires that the last point pair in the matrix is the same as the first point pair, to close the polygon. 


#### Code
1. 
```{r, eval=FALSE}
farmers %>% st_geometry()
st_geometry(farmers)
```

2. 
```{r, eval=FALSE}
st_crs(farmers) <- st_crs(districts)
# p <- "path/to/your/project/notebooks/data"
p <- "~/Desktop"
st_write(farmers, dsn = file.path(p, "farmers.sqlite"))
rm(farmers)
st_read(file.path(p, "farmers.sqlite"))
```

3. 
```{r, eval = FALSE}
class(roads)
str(roads)
class(districts)
str(districts)
```

4. 
```{r, eval=FALSE}
plot(roads %>% st_geometry(), col = "blue")
```

5. 
```{r, eval=FALSE}
plot(districts %>% select(distName), main = "Zambia Districts")
```

6. 
```{r, eval=FALSE}
pts <- st_multipoint(x = cbind(x = c(27, 28, 29), y = c(-13, -14, -15)))
plot(districts %>% st_geometry(), col = "grey")
plot(pts, add = TRUE, col = "orange", pch = 16)
```

### Practice 2
#### Questions
1. At least with this example, pretty negligible--well less than 1% mean absolute error.  It might matter more in other places and with other scales though.  The reason `st_area` knows how to estimate areas is because it invokes `lwgeom::st_geod_area`, which calculates a geodetic surface area.  

2. Because for the time being `sf::plot` is a fair bit faster. However, [this recent twitter thread](https://twitter.com/thomasp85/status/1092412825899810817) suggests that may change soon. 

3. By using `mutate` with `cut` that has break values based on those properties. In our example, we found the breaks using `quantile` and different probabilities/percentile levels that creating tertiles of area. 

## Module 2
1. 
```{r, eval = FALSE}
set.seed(1)
districts %>% sample_n(20) %>% st_area() %>% units::set_units("ha") %>% mean()
```

2. 
```{r, eval = FALSE}
set.seed(1)
roads %>% sample_n(100) %>% st_length() %>% units::set_units("km") %>% mean()
```

3. 
```{r}
plot(st_geometry(districts), col = "lightgrey")
set.seed(1)
farmers %>% filter(season == 2) %>% sample_n(200) %>% st_geometry() %>% 
  plot(col = "red", pch = 20, add = TRUE)
```

4. 
```{r}
districts %>% st_transform(st_crs(roads)) %>% st_geometry() %>% 
  plot(col = "lightgrey")
roads %>%  
  mutate(length = as.numeric(st_length(.) / 1000)) %>% 
  filter(length > 50 & length < 100) %>% st_geometry() %>% 
  plot(col = "red", pch = 20, add = TRUE)
```

5.
```{r}
deciles <- function(x) quantile(x, probs = seq(0, 1, 0.1))
dist_deciles <- districts %>% mutate(area = as.numeric(st_area(.)) / 10^6) %>%
  mutate(acls = cut(area, breaks = deciles(area), include.lowest = TRUE)) %>% 
  group_by(acls) %>% summarize(sum_area = sum(area))  
dist_deciles
#
# #2
cols <- heat.colors(10)
par(mar = rep(0, 4))
plot(st_geometry(dist_deciles), col = cols)
legend(x = "bottomright", pch = 15, col = cols, bty = "n", 
       legend = paste0(1:10, c("st", "nd", "rd", rep("th", 7))))

```



## Module 3
