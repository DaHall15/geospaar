---
title: "Unit 1 - Module 1"
subtitle: "GEOG246-346"
date: "`r Sys.Date()`"
output:
  prettydoc::html_pretty:
    theme: architect
    highlight: github
    fig_caption: yes
    number_sections: yes
    toc_depth: 3
    toc: yes
    css: unit.css
vignette: >
  %\VignetteIndexEntry{Unit 1: Module 1}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  fig.align = "center",
  comment = "#>"
)
library(knitr)
```


# Introduction{#unit1mod1intro}

This unit has two general focus areas: 

1. A overview of the R language, its history, use, strengths, weaknesses, and evolutionary trajectory. 

2. An introduction to the concepts and skills of reproducibility

The first focus area primarily entails reading and watching online resources. The second requires the same plus hands-on work with Rstudio, `R`'s industry-standard [IDE](https://en.wikipedia.org/wiki/Integrated_development_environment), and [git](https://git-scm.com) and [GitHub](https://github.com), which are two tools that are critical to the mission of reproducibility. 

# `R` overview

There is a vast amount of material online about R. We have selected a few resources from among these for you to read and/or watch, so that you get a sense about the language and what it does. _You should complete these assignments by the first class_. 

Roger Peng (Johns Hopkins University) provides a nice history and overview of `R` in this 16 minute [youtube video](https://www.youtube.com/watch?v=STihTnVSZnI) that introduces his own `R` course. This provides some insight into R system the advantages and disadvantages (e.g. memory-dependence) of R, the freedoms associated with using `R`, as well as the basic system design and package ecosystem. 

Hadley Wickham's [introduction section](http://adv-r.had.co.nz/Introduction.html) to his book [*Advanced R*](http://adv-r.had.co.nz) provides a nice bullet-point summary of `R`'s advantages and disadvantages.  

Please also visit the `R`'s [homepage](https://www.r-project.org), the center of the R universe, and particularly [CRAN](http://lib.stat.cmu.edu/R/CRAN/), where official `R` packages live (actually the link provided is the closest CRAN mirror site, which lives at Carnegie Mellon University).

Finally, you might have heard of the `python` programming language, and wonder why you are learning `R`. Good question. You can't throw a rock without hitting a python versus R comparison, and here's [one of the more recent examples of this genre](https://medium.com/@data_driven/python-vs-r-for-data-science-and-the-winner-is-3ebb1a968197). Please have a look, but basically each language has a lot of similarities, and one would do very well to learn both. To this I would add something I have yet to find, which is a comparison of R and python for their ability to handle spatial data (there are comparisons out there, but none really comprehensive, e.g. [this](https://www.quora.com/Which-is-better-for-spatial-analysis-Python-or-R)). Both languages can do it, but my own personal (and admittedly biased and unscientific) sense is that R's capabilities to do standalone spatial analysis are more developed than python's. I think this advantage could continue to grow now that development of the `sf` package (vector data) is well underway, and the new `stars` package (rasters) is starting to move. 

On the other hand, python seems to be preferred for machine learning applications on remote sensing data, and gives the ability to programmatically work with geospatial platforms like [Google's Earth Engine](https://developers.google.com/earth-engine/python_install), QGIS, ArcGIS, and the new [Radiant Earth platform](https://pypi.org/project/radiantearth/). It is also preferred, it seems, for setting up production workflows. So, really, there is a case for learning both languages, and developments such as the new [`reticulate` package](https://rstudio.github.io/reticulate/) from Rstudio make it increasingly possible to use both languages in more integrated fashion, as the need arises. That's a subject for another time (and not this class), but just one more reason why we should think about `R` and `python` rather than `R` or `python`. 

[Back to top](#unit1mod1intro)

# The tools and concepts of reproducibility

## Reproducibility
The first set of skills we are going to learn in this course are not related to R, but more generally to programs and concepts that foster *reproducibility*. What is that? A good working definition of the term, as it relates to scientific computing, is: 

> the ability of a researcher to duplicate the results of a prior study using the same materials as were used by the original investigator. That is, a second researcher might use the same raw data to build the same analysis files and implement the same statistical analysis in an attempt to yield the same results.

That is actually a quote by Goodman, Fanelli, & Ioannidis (2016) in an [e-book on reproducibility](https://www.practicereproducibleresearch.org/core-chapters/2-assessment.html), but it works here. 

Reproducibility is a useful concept/mindset to learn, regardless of whether you are going into academia or industry, as it ultimately makes your life easier, particularly when you have to revisit and revise work. The practice of making your work reproducible also makes it easier to share your work with others. 

A great deal more about reproducibiity is written in the aforementioned book. You should read [this paper](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1003285) in PLOS Computational Biology, which lays out 10 rules for reproducibility.  

## The tools of reproducibility
### Version control and `git`
However, we are going to dive in and go straight to learning some of the tools of reproducibility. First, we are going to learn about `git`. `git` is version control software. Working with version control basically entails maintaining a single set of files (generally code files, but also other kind of documents, but typically not large binary images, such as rasters) for a project, and making changes to those files as you go in a way that keeps those changes out of sight, but makes it easy to recover past changes if you need them. For example, the file that we used to create this html document is called `unit1-module1.Rmd` (it's an Rmarkdown file, which we will be learning more about shortly) is under version control.  I have made many edits to it as I created it, but I have only one version of it visible in the file system. Previous versions of and changes to the file can be found in the prior *commits*.  

The image below illustrates version control--this shows Rstudio's interface to `git`, comparing the text in the paragraph above to the text in the previous committed version of this file: the pink shows the older paragraph, the green the newer one (I changed just a few lines in there)  

```{r out.width = "60%", fig.align='center', echo=FALSE}
include_graphics("fig/u1m1-1.png") 
```
<!-- ![](fig/u1m1-1.png) -->

So, that is a small taste of version control. If you have ever worked with Google Docs, it does its own form of version control--you can look back at previous edits and changes. Using `git` is a bit more explicit and deliberate than that--you have to make commits manually, changes aren't saved automatically, but that's okay, and it helps us choose how much we want to change before committing the file version. 

So why are we using it here? We want to avoid the common practice of many people when they are updating project documents:  make a file, name it something, make a bunch of changes, decide you want to keep the previous version -> make a new copy of the file -> append the date to the filename to track the changes.  Before long you end up with a cluttered directory that might look something like this: 

```bash
├── my_folder
    ├── somefile.txt
    ├── Somefile_jan 20 2018.txt
    ├── somefile_2 Feb2018.txt
    ├── somefile_jan12018.txt
```

You can't remember what's in each file or when you made a particular change, and you start to hunt. Version control helps us keep folders neat and pruned and edits fairly recoverable, so that we can just a single file (in the example above) called `somefile.txt` and keep track of all the changes made to that file. That's why we are going to use `git` in this class. 

### `git` and GitHub
`git` is a program that lives on your local machine. You can make commits locally, and just keep things under version control on your local machine. If you want to collaborate, or even work with your project across multiple machines, you can create a remotely stored version of your `git` project (repository) on [GitHub](https://github.com).  GitHub is one of several web services that provides hosting for git repositories. It also provides useful collaboration functionality. We'll come back to this. 

#### Still not convinced?
Okay, so maybe you finished reading this section and are still wondering why you have to learn `git` and GitHub in an `R` course. Here's a pithier expression of the reasoning:

```{r out.width = "50%", fig.align='center', echo=FALSE}
include_graphics("fig/u1m1-tweet.png") 
```


### Packages

Packages are another tool of reproducibility that we will learn to use in this class. Packages are bundles of code and documentation that provide a specific functionality for a particular language. Both `python` and `R` make extensive use of packages, as the utility of both languages depends heavily on user-contributed code. Code contributions are made through packages, which standardize and formalize the user-developed functions so that they work properly within the language, and can be easily used by the broader community. 
Packages are also useful even if you don't intend to contribute code to the community, as they have a particular structure that can be useful for helping to organize and formalize your thinking, data analysis, and reporting. They can also save you time as they make it much easier to access functions that you have developed for one project and apply them to another. I learned these ideas from reading Hillary Parker's [blog post on personal R packages](https://hilaryparker.com/2013/04/03/personal-r-packages/), as well as Karl Broman's [R package primer](http://kbroman.org/pkg_primer/pages/why.html), and of course Hadley Wickham's [introduction](http://r-pkgs.had.co.nz/intro.html) to his *R packages* book (please read all aforementioned links).

I have adopted the package structure for organizing the analyses and writing of each of my papers. For example, two of my most recent papers are structured as R packages that can be installed as R packages from their GitHub repositories (which can be found [here](https://github.com/agroimpacts/ecoscales) and [here](https://github.com/agroimpacts/croplandbias)). These contain all the code used to do the analyses, create the figures, and full (non-journal formatted) versions of the manuscripts. And (as you may have noticed by now), this class is also structured as an R package.

[Back to top](#unit1mod1intro)

## Setting up your setup

### Installations
The first thing you need to do is to install `R`, Rstudio, and `git` on the machine that you will be using outside of the classroom (you cannot count on the class computers for this). Ideally, you will set up your projects in a cloud-based folder that you can access from the computers in JC103, for sharing large data files (note: `git` and GitHub are not intended for sharing large data files).

- Install `git` by following [links here](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git) to get the version for your OS. If you are installing `git` for Windows, install using the default options. 
- Then install `R` for your OS from Rstudio's link to [CRAN's R downloads](https://cran.rstudio.com) (use default options)
- And then [download] (https://www.rstudio.com/products/rstudio/download/#download) and install Rstudio (use default options).

### Your first Rstudio project

We are going to get our start with Rstudio and our reproducibility tools by using some of Rstudio's handy built-in capabilities.  We are going to do that by creating a new Rstudio project that has the minimal set of files and folders needed for an R package, as well as its own git repository.  

To do this: 

1. Open up Rstudio
2. Find the Packages tab, click install, type "devtools" into the "Packages" dialog, and click install.  You will notice a bunch of stuff installing in the console. 
3. When that is finished, select File > New Project
4. In the new project dialog that pops up, choose "New Directory", and then in the next page, select the "R package using devtools" option at the very bottom. You will see a screen that looks like this:

```{r out.width = "60%", fig.align='center', echo=FALSE}
include_graphics("fig/u1m1-2.png") 
```

5. Here we'll make a couple of decisions:
    - Name the package using your initials (in lowercase) followed by the three digits of the course (246 or 346, depending on which you are enrolled in), e.g. in my case it would be lde346.  
    - Under the "Create project as sub-directory of" enter the folder where you want this project to live. Since this choice impacts your file organization, it touches on the broader theme of reproducibility, and should therefore be a carefully considered choice. For example, you might want to choose the folder in which you keep all course-related work, with this folder being a sub-folder of geog246346. I do not suggest your Desktop as a good location, as shown here. 
    - It is optional whether you want to "Open in a new session" or not.
    - Choose "Create Project"
    
6. You will now have an opened Rstudio project, with the name you selected. You are going to be working in this project for the first two units of the class.  Let's configure Rstudio a bit first. Your first view (assuming this is your first use of Rstudio) will look something like this:
```{r out.width = "40%", fig.align='center', echo=FALSE}
include_graphics("fig/u1m1-3.png") 
```

    Let's modify the pane layout first, by going to Tools > Global Options > Pane Layout, and make it match this: 
```{r out.width = "40%", fig.align='center', echo=FALSE}
include_graphics("fig/u1m1-4.png") 
```

    You can also change the Rstudio theme by going to Tools > Global Options > Appearance (I personally prefer light text on dark backgrounds). Also check the Tools > Terminal tab, and make sure that either "Bash" (Mac/Linux) or "Git Bash" (Windows) are enabled in the "New terminals open with" dialog.

    You should also see a terminal tab next to the console tab:
```{r out.width = "40%", fig.align='center', echo=FALSE}
include_graphics("fig/u1m1-5.png") 
```

    Last thing under Global Options to modify: > Code > Display > Check Show Margin tab, which should have 80 in the margin column value box. 
    
7. Now let's set up some project options that will make our lives easier when build packages. Go to Tools > Project Options, and make it look like this (i.e. check "Generate documentation with Roxygen" and check all boxes in the dialog after click the Configure button): 

```{r out.width = "50%", fig.align='center', echo=FALSE}
include_graphics("fig/u1m1-6.png") 
```

Okay, we are basically set-up with the full set of tools you need. We are now going to learn to work with `git`. 

[Back to top](#unit1mod1intro)

# Using `git` and GitHub

Before we get started with some hands on work with `git`, it is important to understand a bit more about version control than the very brief overview we provided in above. Read the good [explanation of version control systems](https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control) in the [Pro Git book](https://git-scm.com/book/en/v2), which tells us that `git` is a distributed version control system. [Getting Started - Git Basics](https://git-scm.com/book/en/v2/Getting-Started-Git-Basics) explains to us exactly how `git` works and how it is different from other version control softwares. Another important concept to learn is _branching_, which is explained in [this chapter](https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell), and which, in essence, is a way of isolating specific changes you want to make to your code from the main body of your code (which might need to be preserved as is so others can keep using it without it breaking), or, as the book says: 

> Branching means you diverge from the main line of development and continue to do work without messing with that main line

Another post on [git branching](https://nvie.com/posts/a-successful-git-branching-model/) (and merging, which we will come back to) has a more effective schematic for showing the concept and why it is used. 

<p align="center">
  <img width="350" height="465" src="https://nvie.com/img/git-model@2x.png">
</p>

This schematic is oriented towards software development projects. For the purposes of this class, however, you will use a simplified version of this structure to separate your assignments from one another. 

## `git` configuration

If you have just installed `git` on your computer, before we can use it, we need to do a little bit of configuration.  You can either use your terminal (mac/linux), `git bash` terminal (Windows), or the terminal RStudio provides to do this. So, choose the best one of those for you, and then, at the prompt enter:

```bash
git config --global user.name "YOUR GITHUB USER NAME"
git config --global user.email "EMAIL ADDRESS LINKED TO YOUR GITHUB ACCOUNT"
```

Replace the prompt text in the above commands with your GitHub user name and email address associated with your GitHub account, respectively. 

## Your first commit
Let's start to use `git` now. We are going to do this using Rstudio's `git` interface, and the project you just created in the previous section. So open that project (mine is lde346.Rproj, which is found in the lde346 folder on my computer--I can open it and Rstudio up by double-clicking the .Rproj file).

Once in there, click on the "Files" tab, and you will see your directory structure, which should look like what you see in the image below.

```{r out.width = "70%", fig.align='center', echo=FALSE, fig.cap="New Rstudio package project file structure (yellow arrow) and git tab (orange arrow). Rstudio's Editor theme is 'Idle Fingers'."}
include_graphics("fig/u1m1-7.png") 
```


You will also notice the `git` tab in lower left of the image, which has a listing of the same files with yellow boxes with question marks in them under the status section.  This is Rstudio's GUI interface to `git`. You can get the same information by going to Rstudio's terminal tab (upper right), and typing at the prompt in there: `git status`, which gives this output:

```bash
$ git status
On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        .Rbuildignore
        .Rhistory
        .gitignore
        DESCRIPTION
        NAMESPACE
        lde346.Rproj

nothing added to commit but untracked files present (use "git add" to track)
```

The yellow boxes in the `git` GUI are telling us that those files are currently untracked by `git`, i.e. they are not committed to the `git` repo, so if we make any changes to those files, `git` won't know anything about those changes.  So where is the `git` repo, and how do we let it know it should start tracking a file?

The repo itself is a hidden file (it begins with a ".") that lives in the top level of your project directory.  Most file systems by default do not show hidden directories, so if you want to see it, you either have to tell your file explorer to show hidden items, or you can see what's there using a handy command in terminal: `ls -a`, which roughly means list all files in this directory.  

```bash
$ ls -a
.   .Rbuildignore  .Rproj.user  .gitignore   NAMESPACE  lde346.Rproj
..  .Rhistory      .git         DESCRIPTION  R
```

Note the .git. That's folder that contains all the inner workings of a `git` project, which we won't go into but if you are interested you can explore with `ls .git`, which show you the contents.  

To get `git` to track your files, the easiest is to simply check the boxes in the GUI.  For example, check the boxes next to the files ".gitignore", "DESCRIPTION", "NAMESPACE", and the .Rproj file.  You will see the yellow checkmarks changed to green boxes with "A" in them, meaning the files have been staged for a commit.  This is equivalent to going back to terminal, and running the command (note I am using the .Rproj filename for my example):

```bash
git add .gitignore DESCRIPTION NAMESPACE lde346.Rproj
```

I don't really want `git` to track the .Rbuildignore and .Rhistory files, so I want to add these to the .gitignore file, which essentially means `git` will not track those files and they will no longer appear in the `git` GUI with yellow boxes with question marks next to them. To add that, shift-click on the file names (not the check boxes) in the GUI, and then right-click, and choose "ignore" in the dialog that pops up.  That will bring up another box that lists those two files below .Rproj.user.  Click save on the dialog. Immediately you will notice in the GUI that those two files have disappeared, and .gitignore has a blue box with "M" appear next the green A box. That means that the file has been staged to be committed, and has been modified since it was staged.  The check in the box next to it has been replaced by solid blue, meaning the modification has not been staged--to stage it, click the box again, and the blue M will disappear.

We are not ready to make our first commit. So, press the "Commit" button in the GUI, and up will pop a big box, showing the files you added, and giving you a dialog to leave a commit message. The message you put in there should be concise but informative as to what changes you are committing to the repo.

```{r out.width = "60%", fig.align='center', echo=FALSE, fig.cap="RStudio `git` commit window with message"}
include_graphics("fig/u1m1-8.png") 
```

The bottom pane shows the changes being made within the particular file that is selected in the upper left pane (the .gitignore file in this example). The highlighting is green, which means that the lines in questions are being added. If this was a previously committed file that had been changed, you would see a light red line above it that shows the text/code that was in the prior version that is being replaced. You can refer back to the first figure for an example of that, but we can also do the same here with some modifications and a second commit. First though, let's make the commit by simply pressing the "Commit" button in the dialog. Once that is done, you will see a smaller dialog pop-up and tell you the commits that were made, assuming nothing went wrong. Close it when done. Note, that this whole GUI-based commit process (not including the staging) is analagous to running the fulling command in terminal:

```bash
git commit -m "First commit of lde346 project."
```

Now, let's make a change. Go to the file dialog, and double-click the DESCRIPTION file to open it. This is a key part of an R package.  Mine has the following text

```
Package: lde346
Title: What the Package Does (one line, title case)
Version: 0.0.0.9000
Authors@R: person("First", "Last", email = "first.last@example.com", role = c("aut", "cre"))
Description: What the package does (one paragraph).
Depends: R (>= 3.5.2)
License: What license is it under?
Encoding: UTF-8
LazyData: true
```

Change the Title line to something informative, e.g. "GEOG246-346 coursework", and replace the entire Authors@R line with two new lines:

```
Author: Your Name
Maintainer: Your Name <your.email@domain.com>
```

Just for ease. Replace the "Description" with something longer, such as "Package for GEOG246-346 class assignments". 

Once those are done, save the changes, and then go back to the `git` GUI, where you will see a blue M next to the DESCRIPTION file.  Commit the changes with a meaningful message (e.g. "Editing name and purpose in DESCRIPTION"). You will see in the commit dialog how the changes are recorded (old text in red, new in green), and once committed that 4 deletions and 5 insertions were recorded. 

So, that's how changes are tracked and committed in a local `git` repo. You can use the "History" button in the `git` GUI to see the history of your commits and all the changes that they entailed, which you should explore on your own. 

## Syncing your repo using GitHub
Now that you know the basics of `git` commits on your local machine, you'll want to push your project repo to a remote repo hosted on GitHub, and then keep it synchronized with GitHub. There are a few steps we will have to go through to do that. 

[Back to top](#unit1mod1intro)

### SSH keys
First, you will need to create an SSH private-public key pair on your computer, if you don't have one already, and then add that key to GitHub (you will need to do this for each computer you want to connect to GitHub).  The most direct set of instructions, which revolve around RStudio, are found [here](http://r-pkgs.had.co.nz/git.html#git) (and this is generally a greeat resource covering how to work with `git`, GitHub, and `R`/Rstudio) here. To wit, use the following command in the R console:

```{r, eval = FALSE}
file.exists("~/.ssh/id_rsa.pub")
```

If the answer is "False", then you will need to create a new SSH key.  The easiest way to do that is to go into RStudio Tools > Global Options > Git/SVN and click "Create RSA key". Leave the passphrase empty, and click through. Press the View public key button above the SSH RSA Key dialog, and copy the text of the key.  Then follow steps 2-8 [in this GitHub document](https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/#platform-mac) to add the SSH key to your GitHub account. 

If you already have an existing SSH key, then I suggest [following these instructions](https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/) here to get it. 

Once you have that set up, test your SSH connection following [steps 1-4 here](https://help.github.com/articles/testing-your-ssh-connection/), but in place of Step 1 simply go into RStudio's terminal. 

[Back to top](#unit1mod1intro)

### Create new private repo on GitHub

For class assignments, we want to take use private GitHub repositories for assignments, to make them viewable only by select people (you and the course instructore). That means we will have to work through a GitHub organization account. You should already have received an invitation to the agroimpacts organization--if you haven't, ask me for an invite. 

Once you have received your invite, log into GitHub. Find the dropdown box on the left that shows your user name, click on it, and then select the agroimpacts organization. Once in the organization, click on "Create Repository". You will see a dialog that looks like this (except the "Repository name" field will at first be empty):

```{r out.width = "60%", fig.align='center', echo=FALSE}
include_graphics("fig/u1m1-9.png") 
```

Add the repository that matches the name of your local one (i.e. the name of your RStudio project folder), and then leave the rest of the fields as they look in this image, then click "Create Repository". That will bring up another page where you will see your new repository name at the top, followed by "Give access to the people you work with", and then three packages of commands. You want the middle one below the text "…or push an existing repository from the command line". Copy those two commands and paste them into RStudio's terminal (make sure RStudio is opened in your project though).

```bash
git remote add origin https://github.com/agroimpacts/lde346.git
git push -u origin master
```

Note that if you have just set up your SSH keys in RStudio, you might be prompted to enter your GitHub user name and password after the second command.

Now, go back to the GitHub repository, and refresh the page, and you will see your committed files in there. 

We are nearly done with setup. The last thing we will do is add this repository to a secret team that only you and course instructors have access to. To that end, within your new repo, click the "Settings" tab at the top, followed by the "Collaborators and Teams" link at the left, then "Create New Team", name it with your name, add a description ("GEOG246346 assignments"), and set it to secret. That will take you into the page for the new team. Add members besides yourself (course instructors), send them the invites, and then click on the Repositories tab at the top right, click the green "Add repository button", search for it by name, and add it to the team. Change the team permissions to "Write". 

That now makes your repo (and any others you might add to it) secret to just you and the course instructors.

[Back to top](#unit1mod1intro)

### Synchronizing with your remote repo

Now that you have a remote repository, you will want to keep it synchronized. The meets that every time you make a commit in your local repo, you should follow it with a push, to make sure the change is committed onto GitHub.  

You will notice now, if you look back in RStudio's `git` GUI, that the push and pull buttons, which were previously greyed out, are now live. So, that means we can interact with the GitHub repo. Let's first do a push. Reopen your DESCRIPTION file, and change this line:

```
Version: 0.0.0.9000
```

To 
```
Version: 0.0.1
```

Commit the change with a meaningful message ("Updated package version number"), and then once you have done that, press the "Push" button (which you can access either from the big commit dialog, or in the main `git` GUI of RStudio). If you go to your repo on GitHub, you will see your new commit message next to your use icon, above the list of files.  Have a look at the file itself on GitHub to see that the change is in fact now shown on GitHub. 

So that was a "push". What about a "pull"? A pull is done when a change is made on your GitHub repo that is not on your local repo (i.e. your remote repo is ahead of your local repo). How might that happen? In cases where the remote repo is synced to another local repo on another computer, either because you have connected it to a different computer (e.g. your lab computer), or because another person who has access to it has. The act of creating a new local copy of a remote repo is called [cloning](https://git-scm.com/book/en/v1/Git-Basics-Getting-a-Git-Repository#Cloning-an-Existing-Repository). 

In cases where your local repo is behind your remote repo, you can do use the Pull button to bring your remote up to date.  That should usually be enough, although conflicts might arise between your local and remote repo, particularly in cases where the remote is much further ahead.  We won't deal with that right now, however.  

[Back to top](#unit1mod1intro)

### Cloning the remote repo

Instead, let's look at how we can use RStudio to create a new project from your remote repo, which you can use to have the project on both your home and lab computer, so you can make changes from either location.  This is quite simple.  

- On the new machine, which I am assuming already has RStudio set up, complete with `git` and ssh keys connected to your GitHub account, you would simply go to File > New Project > Version Control > Git, 
- Copy into the "Repository name" dialog at the top the full repo path, which you get by going to the repo's main page on GitHub and pressing the big green "Clone or Download" dialog, and copying the resulting URL string. Note you choose to clone using either HTTPs or SSH, which each give slightly different links. You might have to trial and error to get the one that works, but try SSH to start. 
- In the second box (directory name), use the same name as the repo (e.g. lde346), and then choose the directory where you want it live. 
- Check open project in new session, and then voila, you have a local version of the repo fully set up.   

You now have two local copies of the repo, so when you make a change on one, push it to the remote (on GitHub), and then pull the new changes down to the other.  

<span style="color:red">Another note: you can spoof the process described above by simply cloning the GitHub repo on the computer you used to set it up into a different target directory. If you do that, I recommend that, once you have completed the task and closed out of the relevant RStudio session, that you delete the resulting project folder (to avoid confusion).</span> 

[Back to top](#unit1mod1intro)

### Branching

The last thing we are going to do is to set up a new branch in our repo. There is a whole set of instructions how to do that via terminal commands in the [branching and merging section](help.html#branching-and-merging) of the package help vignette. However, setting up a new branch and syncing it with the remote repo is fairly trivial in newer versions of Rstudio.

- Enter the `git` GUI
- Press New Branch, add a new branch name, e.g. "test"
- Make sure the "Sync branch with remote" box is checked
- Click "Create"

The new branch will be added locally and to the remote, and you will be changed into the new branch on your local machine. 

Similarly, if the new branch was created from one local machine, and there is another local machine that doesn't yet have it, you can use the same New Branch dialog, but use the Add Remote button to enter the name of remote branch you want and create it locally.  

Now you can switch back and forth between branches using the dropdown dialog to the right of the New Branch button (or in terminal, `git checkout <branchname>). However, if you make a change to tracked files in the branch you are in and try to switch to another before committing them, you won't be able to. You have to commit changes first. 

To delete the branch, you have to use the terminal (use the RStudio terminal): 
```bash
git branch -d test
git push origin --delete test
```
The first command deletes the local branch (named test), the second that branch on the remote repo. 

[Back to top](#unit1mod1intro)

#### Branching and class assignments
We are going to use branching in this class to keep track of assignments. For the current assignment, you will work in your master branch, making commits as you go.  When you are ready to submit the assignment, you will create a new branch called "ax", where "x" is replaced by the assigmnent number (e.g. "a1" for assignment 1). You will park that branch, and then switch back to master so you can start working on the next assignment. 

### Merging
We will leave the topic of merging for now, but basically merging is quite useful when a small change on one branch (generally a side branch created for the purpose of developing a new feature or fixing a bug) needs to be incorporated into another.  An example might be like this: 

- Create a new branch off of master branch called "fix/description", which in our example is to fix several typos in our DESCRIPTION file
- Make the typo fixes to the version of DESCRIPTION in the new fix/description branch, and commit them.  
- Switch back to master branch (or `git checkout master`)
- Merge the changes

    ```bash
    `git merge fix/description`
    ```

- Push the changes to remote, and then pull to other local repos
- If that is the only time you will use the branch, then delete it (locally and to remote)

In reality, that might be too small of a change to make a whole branch for, but it is useful for illustrating the concept. 

## Best practices

There is a lot written on this, but for now please read the ones provided [here](http://r-pkgs.had.co.nz/git.html#commit-best-practices) in Hadley Wickham's [R packages book](http://r-pkgs.had.co.nz/). The main idea is that commits should be frequent and cover a particular problem, rather than sprawling and involving many files. 

[Back to top](#unit1mod1intro)











