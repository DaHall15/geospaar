---
title: "Unit 2 - Module 2"
subtitle: "GEOG246-346"
date: "`r Sys.Date()`"
output:
  prettydoc::html_pretty:
    theme: architect
    highlight: github
    fig_caption: yes
    number_sections: yes
    toc_depth: 4
    toc: yes
    css: unit.css
vignette: >
  %\VignetteIndexEntry{Unit 2 Module 2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  fig.align = "center",
  comment = "#>"
)
library(knitr)
options(width = 100)
```

***
<center>
[Back to **vignette index**](toc.html)
</center>
***

# Working with raster data{#working-with-raster-data}

We are now going to start working with the `raster` package. `raster` is a highly developed but older package than `sf`, so it was not written with the tidyverse or `sf` in mind. The upshot of this is that operations involving raster-vector interactions will often require coercion of `sf` to `sp` objects. That is not a major obstacle, however. 

The material in this section assumes that the reader is familiar with standard raster GIS operations and concepts, ranging from projections and transformations to moving windows, raster algebra, terrain analysis, and the like. 

We'll use the following datasets in this section:
```{r, message=FALSE, warning=FALSE}
library(geospaar)
farmers <- system.file("extdata/farmer_spatial.csv", package = "geospaar") %>% 
  read_csv() 
roads <- system.file("extdata/roads.shp", package = "geospaar") %>% st_read
districts <- system.file("extdata/districts.shp", package = "geospaar") %>% 
  st_read
```


# raster basics{#raster-basics}
## Raster* classes
We'll start off by learning about the basic `raster` classes, which we will do by building our own objects from scratch, starting with a `RasterLayer`

### RasterLayer
```{r}
# Chunk 1
# #1
e <- extent(c("xmin" = 27, "xmax" = 29, "ymin" = -16, "ymax" = -14))  
#
# #2
r <- raster(x = e, res = 0.25, crs = crs(districts))
#
# #3            
set.seed(1)  
values(r) <- sample(1:100, size = ncell(r), replace = TRUE)  # 3
# r[] <- sample(1:100, size = ncell(r), replace = TRUE) 
# r <- setValues(x = r, values = sample(1:100, size = ncell(r), replace = TRUE))

par(mar = c(0, 0, 0, 4))
plot(st_geometry(districts), col = "grey", reset = FALSE)
plot(r, add = TRUE)
```

We just used several functions from the `raster` package to create a random `raster` named `r` that has a 1/4 degree resolution and covers an area of 2 X 2 degrees in southern Zambia. This particular raster is a temporary one that lives in memory. 

Let's walk through the labelled code. In # 1, we use `raster`'s `extent` function to define the boundaries of the raster, and then in # 2 use the `raster` function to create a raster from the resulting `r class(e)` object `e`, assigning a CRS using the "crs" argument, which in turn uses `raster`'s `crs` to extract the crs from `districts` (#3). `crs` is similar to `sf::st_crs`, but outputs a different class of object that can't be used by `raster`. The `raster` function can create a raster from many different types of input objects (passed to argument "x"), per `?raster`:

> filename (character), Extent, Raster*, SpatialPixels*, SpatialGrid*, object, 'image', matrix, im, or missing. Supported file types are the 'native' raster package format and those that can be read via rgdal

Line # 2 creates an empty raster `r` with no cell values, so in # 3 we assign some randomly selected values into `r`. Note the method of assignment, using the `values` function; there are two other lines commented out below # 3 that show different ways of doing the same job. 

The plot of `r` over `districts` uses the `plot` method defined for `raster*` objects. Note that it automatically creates a continuous legend, and also note that `raster::plot` can work with `sf::plot`. 

Let's look now at the structure of the object `r`.

```{r}
# Chunk 2
r
class(r)
typeof(r)
slotNames(r)
values(r)
# slot(slot(r, "data"), "values")  # identical to values(r)
res(r)
```

`r` is an S4 object that has fairly different slots compared to `sf` objects. We are not going to go into all of them, but it is useful to know the @file, @data, @extent, and @crs slots. @file itself holds a number of slots, but you should know the @file@name slot, which contains the file name and path for grids that that are read in from disk (it is empty in the case of `r`, since it is held in memory). @data contains many slots also, but the main one of interest is the @data@values slot, which can be accessed with the `values` function directly, or less directly using `slot` (both approaches are shown above). Interestingly, the resolution information is not stored in any of the slots of `r`, but rather calculated from the @extent and @ncols and @nrows slots by the `res` function.  

***
<center>
[Back to top](#working-with-raster-data) || [Back to **vignette index**](toc.html)
</center>
***

### RasterStack and RasterBrick

We have just seen how to create a `RasterLayer` and learned a bit about the structure of this kind of object, which is two-dimensional. We are now going to learn about three-dimensional rasters, which come in two flavors: `RasterStack` and `RasterBrick`. Before we proceed, we first need to create some new data. 

```{r}
# Chunk 3
r2 <- r > 50
r3 <- r
set.seed(1)
values(r3) <- rnorm(n = ncell(r3), mean = 10, sd = 2)
l <- list(r, r2, r3)
```

We used r to create two new rasters, `r2` and `r3`. `r2` was made by using a logical operator (`>`) to find the locations where `r`'s values exceed 50, creating a binary `raster` where 1 indicates the matching pixels, and 0 those that don't.  `r3` was made by using `r` as a template, then overwriting the values with numbers generated randomly from a normal distribution (`rnorm`).  These were then combined into list `l`. 

```{r, fig.width=7, fig.height=2.5}
# Chunk 4
s <- stack(l)
# s <- stack(r, r2, r3)  # also works
names(s) <- c("r", "r2", "r3")
s

b <- brick(s)
b

plot(b, nr = 1)
```

In the preceding code blocks, we use `l` to create a `RasterStack` and `RasterBrick`. These are very similar things, but have a few key differences. A `RasterStack` is a series of rasters that have the same extent and resolution, which are "stacked" on top of one another in the order that they are given in the input list. The stacked layers can from any number of files stored in different areas on disk. A `RasterBrick` does the same thing (stacks `RasterLayers` on top of one another), but is more restrictive because the layers, if read off disk, must be contained within a single file. This makes the `RasterBrick` less flexible than the `RasterStack`, but it has the advantage of faster processing times (according to `?brick`). 

Applying `plot` to a stack or brick results in the automatic plotting of each layer into its own sub-window, with coordinates along the plot axes. You can specify numbers of rows and columns in your plotting device using the "nc" and "nr" arguments to `raster::plot`. 

Here's a more informative (by putting it over a map of Zambia) way of plotting the layers in `s` (works for `b` also):

```{r, fig.width=7, fig.height=2.5}
# Chunk 5
par(mfrow = c(1, 3), mar = c(0, 0, 0, 4))
for(i in 1:nlayers(s)) {
  districts %>% st_geometry %>% plot(col = "grey")
  plot(s[[i]], add = TRUE)
}
```

## Reading and writing rasters

So far we have used `Raster*` data that are held in memory. Let's write these out onto disk and then read them back in. Write these to your `notebooks/data` folder (per instructions in [Unit 2 module 1 vignette](unit2-module1.html#set-up). 

```{r, eval = FALSE}
# Chunk 6
# #1 - write to disk
writeRaster(r, filename = file.path(tempdir(), "r.tif"))
writeRaster(r2, filename = file.path(tempdir(), "r2.tif"))
writeRaster(r3, filename = file.path(tempdir(), "r3.tif"))
writeRaster(b, filename = file.path(tempdir(), "b.tif"))

# #2 - read back in each individual raster and recreate stack
r <- raster(file.path(tempdir(), "r.tif"))
r2 <- raster(file.path(tempdir(), "r2.tif"))
r3 <- raster(file.path(tempdir(), "r3.tif"))
s <- stack(list(r, r2, r3))  # recreate stack

# #3 - programmatic creation of stack
fs <- dir(tempdir(), pattern = "r.*.tif", full.names = TRUE)
l <- lapply(fs, raster)
s <- stack(l)
# s <- fs %>% lapply(raster) %>% stack  # pipeline approach works, too

# #4 - read in brick
b <- raster(file.path(tempdir(), "b.tif"))  # incorrect, reads in just 1st layer
b <- brick("external/unit2/data/b.tif")  # correct, reads in whole brick
```

In #1 above, we use `writeRaster` to write out each of the three individual rasters to a geotiff, and write `b` to a three-band geotiff. In #2 we use the `raster` function to read back in the individual rasters, and then recreate stack `s` from those. #3 is a more programmatic way of doing #2, using the `dir` function to read the directory, looking for filenames matching a pattern, and returning the full paths to the matching files. These paths are then used in an `lapply` to read the files in with `raster`, recreating list `l`, which is then stacked. The pipeline approach that wraps up these commands in one line is shown commented out below that. 

Blocks #2 and #3 illustrate how `stack` can be used to create a three-dimensional grid from different files, which differ from what you see next in #4, where the "b.tif" is read back into a brick. You will see the comment there that says that the first line in #4 is incorrect, because using `raster` only results in the first `raster` being read in. 

***
<center>
[Back to top](#working-with-raster-data) || [Back to **vignette index**](toc.html)
</center>
***


## From vector to raster and back again

Now that you know the major `Raster*` classes, and how to read and write them to disk, let's figure out how to change between raster and vector types. 

### Vector to raster
We have several vector datasets that come with `geospaar` which we can rasterize, starting with the district boundaries.   
```{r, out.width="60%"}
# Chunk 7
# #1
zamr <- raster(x = extent(districts), crs = crs(districts), res = 0.1)
values(zamr) <- 1:ncell(zamr)
#
# #2
distsr <- districts %>% mutate(ID = 1:nrow(.)) %>% 
  rasterize(x = ., y = zamr, field = "ID") %>% print()
# districts$ID <- 1:length(districts)
# distsr <- rasterize(x = districts, y = zamr, field = "ID")


par(mar = c(0, 0, 0, 4))
plot(distsr, axes = FALSE, box = FALSE)
```

In #1, we took an initial step to define a raster (`zamr`) that has the  properties of resolution (0.1 decimal degrees), CRS, and extent that we want our rasterized vector to have. We set the extent of this raster to that of `districts`, using `extent` to get the bounding box coordinates (`extent` retrieves the same parameters as `sf::st_bbox`, but the output is in a different format). 

In #2, we use `rasterize` to (as the name says) rasterize `districts`. The "y" argument is where we feed in `zamr`, the raster object that is the "target" for rasterizing `districts`. The "field" argument supplies the column names of the values that we want rasterized. In this case, we has to first create an "ID" variable, in order to give an integer for each district name, as the district names (a character variable) cannot be written to the raster. Notice that we have constructed this as a pipeline (with `print` as the last step, to show the `raster` metadata). The commented out code below it shows how it can be done with more conventional syntax. 

Our plot removes the coordinate-labelled axes and box that otherwise drawn around raster plots by default. 

Next we rasterize the `farmers` dataset, which requires a little more prep to be meaningful: 

```{r, out.width="50%"}
# Chunk 8
# #1
zamr2 <- raster(x = extent(districts), crs = crs(districts), res = 0.25)
values(zamr2) <- 1:ncell(zamr2)

# #2
farmersr <- farmers %>% distinct(uuid, .keep_all = TRUE) %>% 
  select(x, y) %>% mutate(count = 1) %>% 
  st_as_sf(coords = c("x", "y"), crs = 4326) %>% 
  rasterize(x = ., y = zamr2, field = "count", fun = sum) %>% print()

# #3
par(mar = c(0, 0, 1, 4))
districts %>% st_union %>% 
  plot(col = "grey", border = "grey", 
       main = expression(paste("N farmers per 0.25", degree, " cell")))
plot(farmersr, add = TRUE)
```

In #1, we create a coarser scale (0.25 degree) version of `zamr` (`zamr2`), because we want our final raster how count how many farmers responding to our survey are found in each grid cell. The resolution of 0.1 degrees used for `zamr` is a bit too fine to convey the information nicely in a plot.  

In #2, we do the rasterization as part of a pipeline.  The first two lines prepare the `farmers` dataset. Recall that `farmers` consists of weekly reporting data sent to us by a large number of farmers, which means that we have multiple reports sent by the same farmer (and thus repeated coordinates for each farmer). So we need to reduce `farmers` down to just one row for each individual farmer, so that we have just a single set of coordinates for each. We do that by using `distinct` on the *uuid* variable, using `.keep_all = TRUE` so that we retain the coordinates, and add a new `count` variable (which assigns a value of 1 to each farmer) before converting farmers to `sf` in the third line. We then `rasterize` the *count* variable, using the `sum` function to aggregate the number of farmers per 0.25$\circ$ grid cell.  

The resulting plot (#3) shows that most cells have less than 20 farmers. We add an extra plot decoration step, using `expression` with `paste` to add a superscript degree symbol to our plot title. 
 
You can also rasterize line features, much as we did for points and polygons, but `rasterize` is exceedingly slow for lines, so we are not doing that here. However, there is code below that shows how one could so that with the `roads` dataset (subset to roads greater than 100 km long):
```{r, eval = FALSE}
# Chunk 9
roadsr <- roads %>% filter(as.numeric(st_length(.)) > 1000000) %>% 
  mutate(ID = 1:nrow(.)) %>% st_transform(crs = 4326) %>% 
  rasterize(., zamr, field = "ID")
```

***
<center>
[Back to top](#working-with-raster-data) || [Back to **vignette index**](toc.html)
</center>
***

### Raster to vector

`raster` gives us functions that allow us to transform rasters to vectors. 

```{r, fig.width=5, fig.height=4}
# Chunk 10
# #1
dists_fromr <- rasterToPolygons(x = distsr, dissolve = TRUE) %>% st_as_sf

# #2
farmers_fromr <- rasterToPoints(x = farmersr, spatial = TRUE) %>% st_as_sf

par(mar = c(0, 0, 0, 0))
dists_fromr %>% st_geometry %>% plot(col = topo.colors(n = nrow(districts)))
farmers_fromr %>% plot(pch = 20, col = "red", add = TRUE)
```

Vectorizing rasters and vectorizing back again means that you end up with lower  resolution vectors if the raster is fairly coarse. You will note that this has occurred here, both in converting the rasterized districts back to polygons (#1) and the rasterized farmer counts back to points (#2). There are several things to note here. First, we used different functions for vectorizing polygons and points. Second, we piped each vectorization output to `st_as_sf`, because the endresult of the `rasterTo*` functions is an `sp` object, so the extra coerces those to `sf`.

## Projections

Up until now, our `Raster*` data have been in geographic coordinates systems. Let's transform these to projected coordinates, using the rasterized districts as an example. 

```{r, fig.width=7, fig.height=2.5}
# Chunk 11
# #1
zamr_alb <- projectRaster(from = zamr, res = 11000, crs = crs(roads), 
                          method = "ngb")

# #2
distsr_alb <- projectRaster(from = distsr, to = zamr_alb, method = "ngb")

par(mfrow = c(1, 2), mar = c(0, 0, 1, 4))
plot(distsr, main = "GCS rasterized districts", axes = FALSE, box = FALSE)
plot(distsr_alb, main = "Albers rasterized districts", axes = FALSE, box = FALSE)
```

In our first step (#1), we apply `projectRaster` to our `zamr` object, transforming it to the Albers projection used by `roads` (the "crs" argument). We define an output "res" of 11,000 m, or 11 km, which is reasonably close to the 1/10th of a degree resolution of `zamr`. We also choose a "method" for calculating the transformed values in the new raster. In this case, since `zamr` has values that are basically an integer index of grid cells, we use the "ngb" (nearest neighbor) option, to avoid the bilinear interpolation that would occur by default (see `?projectRaster`). 

The result, `zamr_alb`, then becomes a reference raster (i.e. the raster defining the parameters) for other rasters that need to be reprojected, which is how we use it when reprojecting `distsr_alb` (# 2). In this case, we pass `zamr_alb` to the "to" argument, and don't need the "res" or "crs" arguments (because the function reads those values from "zamr_alb"). Here we again use the "ngb" method so that we do not change the values of the categorical identifier of each district. You can see how the interpolation choice matters in the plot below, which compares the bilinear to ngb method--see how the bilinear approach changes values along district boundaries?

```{r, fig.width=7, fig.height=2.5}
# Chunk 12
distsr_alb2 <- projectRaster(from = distsr, to = zamr_alb, method = "bilinear")

par(mfrow = c(1, 2), mar = c(0, 0, 1, 4))
plot(distsr_alb2, main = "Bilinear reprojection", axes = FALSE, box = FALSE)
plot(distsr_alb, main = "Nearest neighbor", axes = FALSE, box = FALSE)
```

A bilinear interpolation is more appropriate for a raster of continuous values, or one where it makes sense to have values averaged during the reprojection process, such as the `farmersr` dataset. 

## Practice
### Questions
1. What is a primary difference between `sf` and `s4` object classes? 

2. What function should you use to read and write a multi-layer raster? 

3. What are the difference between `stack` and `brick`? 

4. What class of object do `raster`'s vectorization functions produce? 

### Code
1. Create a new raster `r4`, using `r3` (above) as a template. Update the values of `r4` using numbers randomly selected from a uniform distribution ranging between 0 and 1. Create another raster `r5` by finding the values greater than 0.5 in r4. Recreate the list `l` with `r`, `r2`, `r3`, `r4`, and `r5`, and then create and plot stack `s2`.

2. Create a new brick `b2` by applying the `brick` function to `s2` and writing it out to disk as `b2.tif`, specifying the path to your `notebooks/data` folder.

3. Following the steps in Chunk 8, recreate `farmersr` by re-rasterizing `farmers` at a 0.2 degree resolution. Plot the result. 

4. Project the new 0.2 degree resolution `farmersr` to an Albers projection with a target resolution of 20 km (20,000 m), calling it `farmersr_alb`. Chunk 11 is your guide, but reproject using a bilinear rather than nearest neighbor interpolation (see `?projectRaster`). Make a two panel plot comparing `farmersr` on the left, plotted over the unioned districts of Zambia in grey, with `farmersr_alb` on the right, plotted over the unioned districts of Zambia in grey (and transformed to Albers). Code in Chunks 8 and 11 can help.   

5. Convert `distsr` to an `sf` polygons object, using `rasterToPolygons` with `dissolve = TRUE`. Plot the result without coercing to `st_geometry`. 


***
<center>
[Back to top](#working-with-raster-data) || [Back to **vignette index**](toc.html)
</center>
***

 

