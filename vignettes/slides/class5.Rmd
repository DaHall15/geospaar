---
title: "Geospatial Analysis with R"
author: "Lyndon Estes & Zhiwen Zhu"
date: "9/13/2017"
output:
  slidy_presentation: 
    default:
    fig_height: 4
    fig_width: 6
subtitle: Class 5
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align = "center")
```

## Overview

- A review of concepts/skills we have learned so far.
    - The essential
    - The important to know
    - The good to know because it might help, now or down the track
- Skills for the next assignment
    - Branching
    - Working with the apply family, data.frames
- Potential projects

## Concepts/skills

- R objects
- R environments


## R objects: 
- Essential: 
    - Main object types: 
        - Data
            - Data types: 
            - Data structures
        - Functions
            - Varying complexity, from `(`, `+`, `-`, to `lm`
        - Results
            - Output objects of varying complexity: vector, data.frame, list (S3), S4
    - Objects versus functions:
    
        "Everything that exists is an object. Everything that happens is a function call" (John Chambers, quoted by [Wickham](http://adv-r.had.co.nz/Functions.html#all-calls))
    
- Important: 
    - More on concept of __object-oriented programming__, from [Advanced R](http://adv-r.had.co.nz/S3.html):       
    
        "Central to any object-oriented system are the concepts of class and method. A class defines a type of object, describing what properties it possesses, how it behaves, and how it relates to other types of objects. Every object must be an instance of some class. A method is a function associated with a particular type of object." 
    
        "While computations are still carried out via methods, a special type of function called a generic function decides which method to call." __[This is what Method Dispatch means]__
    
        "The primary use of OO programming in R is for print, summary and plot methods."

    - Try this on your machines
    
```{r, eval = FALSE}
methods(plot)
```

    - S3 and S4 are the two main OO systems used by R
    - The primary spatial packages that we will use in R use S4 

- Good to know

    - How generic functions are created
    - Precise differences between S3 and S4
        - S4 has fairly different structure
        - Sometimes you will want to get stuff out of an S4 object
        - Getting stuff out of an S4 object can be tricky

## R environments        

Different spaces where objects exist and functions happen

### Essential 
1. Environment hierarchy (from most ancestral to least)

<!-- (Sketch this out with a visual) -->

    - empty
    - base
    - package1
        - package1::fun1
    - package2
        - package2::fun2
    - package3 (e.g. one you created)
        - package3::fun3 (package environment)
        - package3:::unexportedfunction (namespace environment)
    - Global environment
        - exported functions from loaded packages
            - fun1
            - fun2 
            - fun3
        - objects you created
            - data object
            - function you created outside of package
            - summary

2. This hierarchy defines the search path:

Run this to see the hierarchy of your enviroments
```{r, eval = FALSE}
search()
```

Run this to see the environment that encloses (i.e. the namespace) a given function
```{r, eval = FALSE}
f <- function() 1
environment(f)  # global
environment(sum)  # a primitive, written in C, no R code, no env
environment(lm)  # stats
environment(summary)  # an exported generic
```

Recall and run this example, after first installing `raster` and `Hmisc`
```{r, eval = FALSE}
# uncomment and run if you need to
# install.packages(c("Hmisc", "raster"))  
library(raster)
library(Hmisc)
mask
search()
detach("package:raster", unload=TRUE)
detach("package:Hmisc", unload=TRUE)
library(Hmisc)
library(raster)
mask
```

3. Where packages live: 

When you are building them, versus when they are installed. 

### Important/Good to Know

"...every package has two environments associated with it: the package environment and the namespace environment. The package environment contains every publicly accessible function, and is placed on the search path. The namespace environment contains all functions (including internal functions), and its parent environment...contains bindings to all the functions that the package needs. Every exported function in a package is bound into the package environment, but enclosed by the namespace environment. This complicated relationship is illustrated by the following diagram" From [Advanced R](http://adv-r.had.co.nz/Environments.html#function-envs)

<!--     - Method dispatch (object-oriented programming) -->
<!--     - Name-masking (name-space) -->

## New skills
### Git branching

To create a new branch in your git repo, in shell (best to open from Rstudio)

Creates the new branch and switches you in to it
```
git checkout -b newbranchname
```

Commit your new branch to GitHub
```
git push origin newbranchname
```

To switch into an existing branch
```
git checkout somebranchname
```

## New skills
### (Pseudo) Random number generation

You will end up generating random data for many purposes, so here are a few ways to do that. 

- Random integers
```{r}
a <- sample(x = 1:20, size = 30, replace = TRUE)
a
hist(a)
```

- Random number from a uniform distribution
```{r}
b <- runif(n = 30, min = 10, max = 20)
b
hist(b)
```

- Random number from a normal distribution
```{r}
d <- rnorm(n = 30, mean = 15, sd = 2)
d
hist(d)
```

- Make sure you get the same random numbers every time
```{r}
set.seed(2)
a <- sample(x = 1:20, size = 30, replace = TRUE)
b <- runif(n = 30, min = 10, max = 20)
d <- rnorm(n = 30, mean = 15, sd = 2)
par(mfrow = c(1, 3))
hist(a)
hist(b)
hist(d)
```

- Try repeating this, using different seed values, and also running the code as a block, or stepping through it line by line. 

## New Skills
### Indexing

To extract subsets from different types of data structures

- With numeric index values
```{r, which = FALSE}
# Vectors
a <- 1:10
a[10]  # 10th values of A
a[c(1, 3)]  # 1st and 3rd values in A

# matrices
mat <- cbind(a = 1:10, b = 1:10, c = 1:10)
mat[1, 1]  # row 1, column 1
mat[, 3]  # all of column 3
mat[2, ]  # all of row 2

# data.frames
d <- c(rep("pigs", 3), rep("ponies", 4), rep("puppies", 3))
dat <- cbind.data.frame(mat, d)
dat[1, 1]  # row 1, column 1
dat[, 3]  # all of column 3
dat[2, ]  # all of row 2
dat[2:4, 3:4]  # rows 2:4 in columns 3:4
dat[2:4, c(2, 4)]  # rows 2:4 in columns 2 and 4

# lists
l <- list(a, mat, dat)
names(l) <- c("a", "mat", "dat")  # give the list names
l[[1]]  # first element (a)
l[[3]]  # third element (dat)
l[[3]][2:4, c(2, 4)]  # rows 2:4 in col 2 & 4 in 3rd element
```

- By name
```{r, eval = FALSE}
names(a) <- letters[1:length(a)]
a["f"]

mat[1, "a"]
mat[, "b"]

dat[1, "d"]
dat[, "c"]

l$a
l$mat
l$dat[2:4, c("b", "d")]
```

- Matching
```{r, eval = FALSE}
dat[dat$d == "pigs", ]  # all rows of dat where d == "pigs"
dat[dat$d == "pigs", 1]  # all values from a where d == "pigs"
dat[dat$d == "pigs", "a"]  # all values from a where d == "pigs"

# another way
dat[dat[, 4] == "pigs", ]  # all rows of dat where d == "pigs"
dat[dat[, 4] == "pigs", 1]  # all values from a where d == "pigs"
dat[dat[, 4] == "pigs", "a"]  # all values from a where d == "pigs"
```

## New skills
### Control structures

Very important, particularly the apply family of functions

- First, `for` loops, which occur in all languages
```{r, eval = FALSE}
for(i in 1:10) {
  print(dat[i, "a"] * 10)
}  # Where are the results kept? 

a <- rep(NA, 10)
for(i in 1:10) {
  a[i] <- dat[i, "a"] * 10
}  # Where are the results kept? 
a
```

- The output of `for` has to be "caught" in an object you define
- One reason we use the `*apply` family is because it is designed to put results into an object
    - `apply` applies a function to the rows or columns of a data.frame or matrix
    
    
```{r, eval = FALSE}
aa <- apply(dat[, 1:3], 1, sum)  # sum across columns
aa
bb <- apply(dat[, 1:3], 2, sum)  # sum across rows
bb
```

    In the example above, why did I only take the first 3 columns of dat? 
    
    - `sapply` operates on a list, or using an index of your choosing, and produces an output vector or data.frame
    
    
```{r, eval = FALSE}
cc <- sapply(l, function(x) sum(x[1:2]))
cc
dd <- sapply(1:10, function(x) sum(dat[x, 1:3]))
dd
```

    - `lapply` also operates on a list, or applies a function to an index of your choosing, but returns a list

```{r, eval = FALSE}
ee <- lapply(l, function(x) sum(x[1:2]))
ee
ff <- lapply(1:10, function(x) sum(dat[x, 1:3]))
ff
```

    - In general, if you want to keep the output of your iterative operation, best look to `*apply`. If not, `for` loops can be useful  


    
    



















