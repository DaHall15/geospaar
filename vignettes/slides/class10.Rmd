---
title: "Geospatial Analysis with R"
author: "Lyndon Estes & Zhiwen Zhu"
date: "10/2/2017"
output:
  slidy_presentation: 
    default:
    css: custom.css
    fig_height: 4
    fig_width: 6
subtitle: Class 10
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# options(repos = c(CRAN = "http://ftp.ussg.iu.edu/CRAN/"))
```


## Today

- Extra labs: 
    - Focused on git/GitHub/RStudio/R interactions
    - See me in office hours/by appointment
- Today: plotting and regressions
- Today's data
```{r}
fnm <- system.file("extdata/farmer_test2.csv", package = "geospaar")
farmers <- read.csv(fnm, stringsAsFactors = FALSE)
```

## Practical assignment

1. Use `lapply` and `sapply` to calculate the `colSums` (columns "pl", "ra", "mm") for observations where "uuid" contains the values "8424", "166f", "99f9". This means you will have to use the grep approach to subsetting, rather than `farmers[farmers$date == x, c("pl", "ra", "mm")]`

2. Use `write.csv` to write out the outputs of the `sapply` version of this, where you have the results for "pl", "ra", "mm" as columns, and the partial strings as rows. 

3. Calculate the sum of "ra" for each date in `farmers`. Plot the results against date.

## Some more on lapply/sapply

Key points made in `swirl` exercises: 

1. `lapply`/`sapply` are primarily used for split-apply-combine operations.
2. *apply used:
    - most simply with pre-existing functions (and uncomplicated subsets)
        - e.g. `apply(somedata, 2, sum)`; `sapply(data, sum)`
    - or with anonymous functions (for operations not defined by existing function, e.g. a custom or complicated subsetting/splitting operation)
        - e.g. our operations by date or by uuid on `farmers`
3. Not stated, but the reason that `for` not typically used: 
    - harder to do the combine step
    - more work to *apply* a function, even pre-defined ones
    
        ```{r}
        out <- rep(NULL, 3)
        for(i in colnames(farmers)[3:5]) {
          out[i] <- sum(farmers[, i])
        }
        out
        ```
    Versus
        ```{r}
        out <- sapply(farmers[, 3:5], sum)
        out
        ```
        
## Plotting 

First a note: 
    - Base graphics
    - `ggplot2`
    - Why are we using `base`?
    
Base 
```{r, fig.width=3, fig.height=3, fig.align='center'}
dates <- unique(farmers$date)
rasum <- sapply(dates, function(x) {
  sum(farmers[farmers$date == x, "ra"])
})
dat <- cbind.data.frame("date" = as.Date(dates), rasum)

# base
plot(dat$date, dat$rasum) 

# ggplot
library(ggplot2)
p <- ggplot(dat) + aes(x = date, y = rasum) + geom_point()
p

```

## The answer
```{r, echo = FALSE, fig.align='center'}
options(repos = c(CRAN = "http://ftp.ussg.iu.edu/CRAN/"))
# select CRAN task views that relate to spatial data
library(ctv)
library(data.table)
av <- ctv::available.views()
topics <- sapply(av, function(x) x$topic)
spatviews <- av[grep("spati", topics, ignore.case = TRUE)]
spatpkgs <- unlist(sapply(spatviews, function(x) x$packagelist$name))
spatpkgs <- unique(spatpkgs)  # all spatial packages

# All packages, and then grab the subset of spatial packages in thos
pkgs <- data.table(available.packages())
pkgs <- pkgs[Package %in% spatpkgs, ]

# subset those depending/importing/suggesting on sp
sppkgs <- pkgs[, {
  a = Package[like(Imports, "sp")]
  b = Package[like(Depends, "sp")]
  d = Package[like(Suggests, "sp")]
  unique(c(a, b, d))
}]

# and those relating depending/importing/suggesting ggplot2 and relatives
ggpkgs <- pkgs[, {
  a = Package[like(Imports, "plyr|gg|tidy")]
  b = Package[like(Depends, "plyr|gg|tidy")]
  d = Package[like(Suggests, "plyr|gg|tidy")]
  unique(c(a, b, d))
}]

# make a barplot showing relative frequency of 
ggtot <- length(ggpkgs)  # packages related to tidyverse
sptot <- length(sppkgs)  # sp dependent packages
both <- length(which(sppkgs %in% ggpkgs))  # package using both
barplot(c(sptot, ggtot, both), col  = c("red3", "blue", "purple"),
        names.arg = c("sp", "tidy", "both"), ylim = c(0, 170),
        ylab = "N packages",
        main = "The Tidyverse and R Spatial Packages",
        sub = "As of October, 2017")

```

## Base plotting 1

Formula argument versus x, y arguments
```{r, eval = FALSE}
plot(rasum ~ date, data = dat)
plot(x = dat$date, y = dat$rasum)
plot(dat$rasum, xaxt = "n")
axis(1, at = 1:length(1:length(dat$rasum)), 
     labels = letters[1:length(dat$rasum)])
```

Embellish - your existing plot
```{r, eval = FALSE}
quartz(height = 7, width = 7)
plot(x = dat$date, y = dat$rasum, xlab = "date", 
     ylab = "ra total", pch = 20, col = "blue", cex = 2, 
     las = 2)  # an extra step--rotate axis values
```

## Bonus base plots

A few that weren't shown in class

Custom plotting - use axis to place labels that are different than the ones that actually make up your x-axis
```{r}
plot(x = dat$date, y = dat$rasum, xlab = "letters", 
     ylab = "ra total", pch = 20, col = "blue", cex = 2, 
     xaxt = "n")  # don't display x-axis
axis(1, at = dat$date, labels = letters[1:nrow(dat)])
```

Plotting with a single variable. Note that without a y value given, the value passed to x actually gets put on the y axis, plotted against a dummy index on the x axis, which is `1:length(value you are passing to x)` -- in this case it is `1:length(dat$rasum)`, or, more simply, `1:nrow(dat)`, since the number of rows in (`nrow(dat)`) is equal to the length of each vector bound together in `dat`, e.g. `length(dat$rasum)`, `length(dat$date)`, etc. 
```{r}
plot(x = dat$rasum, ylab = "ra total", pch = 20, col = "blue", cex = 2)
```

Here is a place where using the `axis` function can be particularly useful
```{r}
plot(dat$rasum, xlab = "letters", 
     ylab = "ra total", pch = 20, col = "blue", cex = 2, 
     xaxt = "n")  # don't display x-axis
# axis(1, at = 1:length(dat$rasum), labels = letters[1:1:length(dat$rasum)])
axis(1, at = 1:nrow(dat), labels = letters[1:nrow(dat)])  # same as above
```



## Base Plotting 2

Multi-plots. Side by side. 

First, take 5 minutes to make this dataset from `farmers`. Call it `farmers2`. Sum the date-wise values of "pl", "ra", and "mm" variables, using `sapply`, and the unique dates to split them (remember the `dates` vector we made in previous classes, using the `unique` function).

(Also remember that the code is available to take a peak at it in the .Rmd file)

```{r, echo = FALSE}
dates <- unique(farmers$date)  # forgot to make this explicit before class

# the fast way
farmers2 <- t(sapply(dates, function(x) {
  dat <- farmers[farmers$date == x, c("pl", "ra", "mm")]
  colSums(dat)
}))

# broken down into sapply and then t steps
farmers2 <- sapply(dates, function(x) {
  dat <- farmers[farmers$date == x, c("pl", "ra", "mm")]
  colSums(dat)
})
farmers2 <- t(farmers2)

# bind dates, and change row names of farmers2 from dates to integers
farmers2 <- cbind.data.frame("date" = as.Date(dates), farmers2)
rownames(farmers2) <- 1:nrow(farmers2)  # rownames were dates, want just as #
farmers2
str(farmers2)
```

Next, make three plots, one each for column "pl", "ra", "mm" as y, with date as x. Start ___without___ a for loop
```{r, eval = FALSE, echo = FALSE}
# par defines initial plot parameters, here a figure with 1 row and 3 columns
par(mfrow = c(1, 3))
plot(farmers2$date, farmers2$pl, pch = 20, col = "orange", cex = 2)
plot(farmers2$date, farmers2$ra, pch = 20, col = "blue", cex = 2)
plot(farmers2$date, farmers2$mm, pch = 20, col = "red", cex = 2)
```

## Base plotting 3

Now we'll do the previous, but using a `for` loop. Also be sure to ask me about controlling figure margins.

Start simply, to just get this. This is not very flexible because we can only change the value of column value with each iteration of the `for` loop. 

```{r, fig.width=7, fig.height=3, fig.align="center"}
par(mfrow = c(1, 3))
for(i in c("pl", "ra", "mm")) { 
  x <- farmers2$date
  y <- farmers2[, i]
  plot(x, y)
}
```

And then this. Note that in this case, by changing the `i` value to an index number, we can change the values for column names, colors, and y axis labels with each iteration of the `for` loop.

```{r, fig.width=7, fig.height=3, fig.align="center"}
inms <- c("pl", "ra", "mm")
cols <- c("orange", "red", "blue")
ynms <- c("Plant", "Rain", "Tot rain")
par(mfrow = c(1, 3))
for(i in 1:length(inms)) {  # i = 2
  x <- farmers2$date
  y <- farmers2[, inms[i]]
  plot(x, y, pch = 20, col = cols[i], xlab = "Date", 
       ylab = ynms[i])
}
```

## Base plotting 4

Do the previous, but instead of xy plot, I want a three-panel histogram of "pl", "ra", "mm", with the the bar colors respectively orange, red, blue.

Here's a single one to get started
```{r}
hist(farmers2$pl, col = "orange")
```

## Regressions, including fitted predicted results

Let's fit a regression between N farmers planting per date, and the total rainfall. 
```{r}
pl_lm <- lm(pl ~ mm, data = farmers2)
# summary(pl_lm)
# coef(pl_lm)
```

And plot the results, three ways
```{r}
plot(farmers2$mm, farmers2$pl)  # base plot

# method 1 - the abline function
abline(pl_lm, lwd = 10)  

# method 2 - the predict function
dummy <- seq(0, 7100, 100)  # first, dummy x value data 
method1_predict <- predict(pl_lm, newdata = data.frame("mm" = dummy))
lines(dummy, method1_predict, lwd = 5, col = "red")

# method 3 - manually, using coefficients from linear model
cfs <- coef(pl_lm)  # coefficients
manual_predict <- cfs[1] + cfs[2] * dummy  # predict by hand using coeff.
lines(dummy, manual_predict, col = "blue1", lwd = 1)

```


## Answers to previous exercises

### `lapply`/`sapply` and `colSums`

Two possible interpretations, starting with this, the column sums for all farmers whose IDs match those values. 
```{r, eval = FALSE}
farmers$date <- as.Date(farmers$date)
farmers <- farmers[order(farmers$date), ]  # reorder farmers by date
dates <- unique(farmers$date)  # unique dates

# interpretation 1: grep
colSums(farmers[grep("8424|166f|99f9", farmers$uuid), c("pl", "ra", "mm")])

# interpretation 2the column sums for the farmer matches to each id
t(sapply(c("8424", "166f", "99f9"), function(x) {
  dat <- farmers[grep(x, farmers$uuid), c("pl", "ra", "mm")]
  colSums(dat)
}))
```

### write.csv

```{r, eval = FALSE}
write.csv(farmer_out, file = "~/Desktop/farmer_out.csv")  # easiest
write.csv(farmer_out, file = "~/Desktop/farmer_out.csv", 
          row.names = FALSE)  # no row names

# recreate and then append to same csv
write.csv(farmer_out, file = "~/Desktop/farmer_out.csv")
write.table(farmer_out, file = "~/Desktop/farmer_out.csv", append = TRUE, 
            sep = ",", col.names = FALSE)  # use write.table to append

# save as R data file, using multiple possible extensions
save(farmer_out, file = "~/Desktop/farmer_out.rda")  # common
rm(list = ls())
load("~/Desktop/farmer_out.rda")
save(farmer_out, file = "~/Desktop/farmer_out.Rdata")
load("~/Desktop/farmer_out.Rdata")  # common
save(farmer_out, file = "~/Desktop/farmer_out.rd")
load("~/Desktop/farmer_out.rd")  # don't use this extension!
```
