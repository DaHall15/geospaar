---
title: "Geospatial Analysis with R"
author: "Lyndon Estes & Zhiwen Zhu"
date: "9/27/2017"
output:
  slidy_presentation: 
    default:
    css: custom.css
    fig_height: 4
    fig_width: 6
subtitle: Class 10
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(repos = c(CRAN = "http://ftp.ussg.iu.edu/CRAN/"))
```


## Today

- Extra labs: 
    - Focused on git/GitHub/RStudio/R interactions
    - See me in office hours/by appointment
- Today: plotting and regressions
- Today's data
```{r}
fnm <- system.file("extdata/farmer_test2.csv", package = "geospaar")
# reload data
farmers <- read.csv(fnm, stringsAsFactors = FALSE)
```

## Practical assignment

1. Use `lapply` and `sapply` to calculate the `colSums` (columns "pl", "ra", "mm") for observations where "uuid" contains the values "8424", "166f", "99f9". This means you will have to use the grep approach to subsetting, rather than `farmers[farmers$date == x, c("pl", "ra", "mm")]`

2. Use `write.csv` to write out the outputs of the `sapply` version of this, where you have the results for "pl", "ra", "mm" as columns, and the partial strings as rows. 

3. Calculate the sum of "ra" for each date in `farmers`. Plot the results against date.

## Some more on lapply/sapply

Key points made in `swirl` exercises: 

1. `lapply`/`sapply` are primarily used for split-apply-combine operations.
2. *apply used:
    - most simply with pre-existing functions (and uncomplicated subsets)
        - e.g. `apply(somedata, 2, sum)`; `sapply(data, sum)`
    - or with anonymous functions (for operations not defined by existing function, e.g. a custom or complicated subsetting/splitting operation)
        - e.g. our operations by date or by uuid on `farmers`
3. Not stated, but the reason that `for` not typically used: 
    - harder to do the combine step
    - more work to *apply* a function, even pre-defined ones
    
        ```{r}
        out <- rep(NULL, 3)
        for(i in colnames(farmers)[3:5]) {
          out[i] <- sum(farmers[, i])
        }
        out
        ```
    Versus
        ```{r}
        out <- sapply(farmers[, 3:5], sum)
        out
        ```
        
## Plotting 

First a note: 
    - Base graphics
    - `ggplot2`
    - Why are we using `base`?
    
Base 
```{r, fig.width=3, fig.height=3, fig.align='center'}
dates <- unique(farmers$date)
rasum <- sapply(dates, function(x) {
  sum(farmers[farmers$date == x, "ra"])
})
dat <- cbind.data.frame("date" = as.Date(dates), rasum)

# base
plot(dat$date, dat$rasum) 

# ggplot
library(ggplot2)
p <- ggplot(dat) + aes(x = date, y = rasum) + geom_point()
p

```

## The answer
```{r, echo = FALSE, eval = FALSE}
# options(repos = c(CRAN = "http://ftp.ussg.iu.edu/CRAN/"))
# select CRAN task views that relate to spatial data
library(ctv)
library(data.table)
av <- available.views(repos = "http://ftp.ussg.iu.edu/CRAN/")
topics <- sapply(av, function(x) x$topic)
spatviews <- av[grep("spati", topics, ignore.case = TRUE)]
spatpkgs <- unlist(sapply(spatviews, function(x) x$packagelist$name))
spatpkgs <- unique(spatpkgs)  # all spatial packages

# All packages, and then grab the subset of spatial packages in thos
pkgs <- data.table(available.packages())
pkgs <- pkgs[Package %in% spatpkgs, ]

# subset those depending/importing/suggesting on sp
sppkgs <- pkgs[, {
  a = Package[like(Imports, "sp")]
  b = Package[like(Depends, "sp")]
  d = Package[like(Suggests, "sp")]
  unique(c(a, b, d))
}]

# and those relating depending/importing/suggesting ggplot2 and relatives
ggpkgs <- pkgs[, {
  a = Package[like(Imports, "plyr|gg|tidy")]
  b = Package[like(Depends, "plyr|gg|tidy")]
  d = Package[like(Suggests, "plyr|gg|tidy")]
  unique(c(a, b, d))
}]

# make a barplot showing relative frequency of 
ggtot <- length(ggpkgs)  # packages related to tidyverse
sptot <- length(sppkgs)  # sp dependent packages
both <- length(which(sppkgs %in% ggpkgs))  # package using both
barplot(c(sptot, ggtot, both), col  = c("red3", "blue", "purple"),
        names.arg = c("sp", "tidy", "both"), ylim = c(0, 170),
        ylab = "N packages",
        main = "The Tidyverse and R Spatial Packages",
        sub = "As of October, 2017")

```

## Base plotting 1

Formula argument versus x, y arguments
```{r, eval = FALSE}
plot(rasum ~ date, data = dat)
plot(dat$date, dat$rasum)
```

Embellish - your existing plot
```{r, eval = FALSE}
plot(dat$date, dat$rasum, xlab = "date", ylab = "ra total",
     pch = 20, col = "red", cex = 2, # up to here was exercise given
     las = 2)  # an extra step--rotate axis values
```

## Base Plotting 2

Multi-plots. Side by side. 

First, take 5 minutes to make this dataset from `farmers`. Call it `farmers2`. Sum the date-wise values of "pl", "ra", and "mm" variables, using `sapply` 

```{r, echo = FALSE}
farmers2 <- t(sapply(dates, function(x) {
  dat <- farmers[farmers$date == x, c("pl", "ra", "mm")]
  colSums(dat)
}))
farmers2 <- cbind.data.frame("date" = as.Date(dates), farmers2)
rownames(farmers2) <- 1:nrow(farmers2)  # rownames were dates, want just as #
farmers2
str(farmers2)
```

Next, make three plots, one each for column "pl", "ra", "mm" as y, with date as x. Start ___without___ a for loop
```{r, eval = FALSE, echo = FALSE}
# par defines initial plot parameters, here a figure with 1 row and 3 columns
par(mfrow = c(1, 3))
plot(farmers2$date, farmers2$pl, pch = 20, col = "orange", cex = 2)
plot(farmers2$date, farmers2$ra, pch = 20, col = "blue", cex = 2)
plot(farmers2$date, farmers2$mm, pch = 20, col = "red", cex = 2)
```

## Base plotting 3

Now we'll do the previous, but using a `for` loop. Also be sure to ask me about controlling figure margins.

Start simply, to just get this

```{r, echo = FALSE, fig.width=7, fig.height=3, fig.align="center"}
par(mfrow = c(1, 3))
for(i in c("pl", "ra", "mm")) {
  x <- farmers2$date
  y <- farmers2[, i]
  plot(x, y)
}
```

And then this.

```{r, echo = FALSE, fig.width=7, fig.height=3, fig.align="center"}
inms <- c("pl", "ra", "mm")
cols <- c("orange", "red", "blue")
par(mfrow = c(1, 3))
for(i in 1:length(inms)) {
  x <- farmers2$date
  y <- farmers2[, inms[i]]
  plot(x, y, pch = 20, col = cols[i])
}
```

## Base plotting 4

Do the previous, but instead of xy plot, I want a three-panel histogram of "pl", "ra", "mm", with the the bar colors respectively orange, red, blue.

Here's a single one to get started
```{r}
hist(farmers2$pl, col = "orange")
```

## Regressions, including fitted predicted results

Let's fit a regression between N farmers planting per date, and the total rainfall. 
```{r}
pl_lm <- lm(pl ~ mm, data = farmers2)
# summary(pl_lm)
# coef(pl_lm)
```

And plot the results, three ways
```{r}
plot(farmers2$mm, farmers2$pl)  # base plot

# method 1 - the abline function
abline(pl_lm, lwd = 10)  

# method 2 - the predict function
dummy <- seq(0, 7100, 100)  # first, dummy x value data 
method1_predict <- predict(pl_lm, newdata = data.frame("mm" = dummy))
lines(dummy, method1_predict, lwd = 5, col = "red")

# method 3 - manually, using coefficients from linear model
cfs <- coef(pl_lm)  # coefficients
manual_predict <- cfs[1] + cfs[2] * dummy  # predict by hand using coeff.
lines(dummy, manual_predict, col = "blue1", lwd = 1)

```


## Answers to previous exercises

### `lapply`/`sapply` and `colSums`

Two possible interpretations, starting with this, the column sums for all farmers whose IDs match those values. 
```{r, eval = FALSE}
farmers$date <- as.Date(farmers$date)
farmers <- farmers[order(farmers$date), ]  # reorder farmers by date
dates <- unique(farmers$date)  # unique dates

# interpretation 1: grep
colSums(farmers[grep("8424|166f|99f9", farmers$uuid), c("pl", "ra", "mm")])

# interpretation 2the column sums for the farmer matches to each id
t(sapply(c("8424", "166f", "99f9"), function(x) {
  dat <- farmers[grep(x, farmers$uuid), c("pl", "ra", "mm")]
  colSums(dat)
}))
```

### write.csv

```{r, eval = FALSE}
write.csv(farmer_out, file = "~/Desktop/farmer_out.csv")  # easiest
write.csv(farmer_out, file = "~/Desktop/farmer_out.csv", 
          row.names = FALSE)  # no row names

# recreate and then append to same csv
write.csv(farmer_out, file = "~/Desktop/farmer_out.csv")
write.table(farmer_out, file = "~/Desktop/farmer_out.csv", append = TRUE, 
            sep = ",", col.names = FALSE)  # use write.table to append

# save as R data file, using multiple possible extensions
save(farmer_out, file = "~/Desktop/farmer_out.rda")  # common
rm(list = ls())
load("~/Desktop/farmer_out.rda")
save(farmer_out, file = "~/Desktop/farmer_out.Rdata")
load("~/Desktop/farmer_out.Rdata")  # common
save(farmer_out, file = "~/Desktop/farmer_out.rd")
load("~/Desktop/farmer_out.rd")  # don't use this extension!
```
